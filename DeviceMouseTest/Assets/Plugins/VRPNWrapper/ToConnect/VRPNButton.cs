/* ========================================================================
 * PROJECT: UART
 * ========================================================================
 * Portions of this work are built on top of VRPN which was developed by
 *   Russell Taylor
 *   University of North Carolina
 * http://www.cs.unc.edu/Research/vrpn/
 *
 * We acknowledge the CISMM project at the University of North Carolina at Chapel Hill, supported by NIH/NCRR
 * and NIH/NIBIB award #2P41EB002025, for their ongoing  * support and maintenance of VRPN.
 *
 * Portions of this work are also built on top of the VideoWrapper,
 * a BSD licensed video access library for MacOSX and Windows.
 * VideoWrapper is available at SourceForge via 
 * http://sourceforge.net/projects/videowrapper/
 *
 * Copyright of VideoWrapper is
 *     (C) 2003-2010 Georgia Tech Research Corportation
 *
 * Copyright of the new and derived portions of this work
 *     (C) 2010 Georgia Tech Research Corporation
 *
 * This software released under the Boost Software License 1.0 (BSL1.0), so as to be 
 * compatible with the VRPN software distribution:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy 
 * of the software and accompanying documentation covered by this license (the "Software") to use, 
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative 
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant,
 * this restriction and the following disclaimer, must be included in all copies of the Software, in
 * whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
 * OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * For further information regarding UART, please contact 
 *   Blair MacIntyre
 *   <blair@cc.gatech.edu>
 *   Georgia Tech, School of Interactive Computing
 *   85 5th Street NW
 *   Atlanta, GA 30308
 *
 * For further information regarding VRPN, please contact 
 *   Russell M. Taylor II
 *   <taylor@cs.unc.edu>
 *   University of North Carolina, 
 *   CB #3175, Sitterson Hall,
 *   Chapel Hill, NC 27599-3175
 *
 * ========================================================================
 ** @author   Alex Hill (ahill@gatech.edu)
 *  @modified by    Andrés Roberto Gómez (and-gome@uniandes.edu.co)
 * ========================================================================
 *
 * VRPNButton.cs
 *
 * Usage: Add this script to a GameObject
 * 
 *
 * Notes:
 *
 * ========================================================================*/

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Runtime.InteropServices;

public class VRPNButton : MonoBehaviour {
    // TODO
    // 1. Should VRPNAnalogStart use the "max" reports variable
    // 2. Create read-only list of buttons and their current values
    // 3. Create event/message driven reporting system


    // VRPN Button Report Structure    
    [ StructLayout( LayoutKind.Sequential, Pack=0 )]
    [Serializable]
    public struct ButtonReport
	{
    	public VRPNManager.TimeVal msg_time;
     	public int button;
     	public int state;
 	}

    //Structure to serialize button reports
    [Serializable]
    public class ButtonReports
    {
        public string deviceType;
        public string deviceName;
        public List<ButtonReportNew> list = new List<ButtonReportNew>();
    }

    //Serializable button report
    [Serializable]
    public struct ButtonReportNew
    {
        public VRPNManager.TimeValNew msg_time;
        public int button;
        public int state;
    }

    // Class Properties
    public static int num_buttons = 0;

    // Public Properties
    public VRPNManager.Button_Types ButtonType = VRPNManager.Button_Types.vrpn_Mouse;
    public VRPNDeviceConfig.Device_Names ButtonName = VRPNDeviceConfig.Device_Names.Mouse0;
    //public VRPNManager.Button_Types ButtonType = VRPNManager.Button_Types.vrpn_XInputGamepad;
    //public VRPNDeviceConfig.Device_Names ButtonName = VRPNDeviceConfig.Device_Names.XInput0;
    private int ButtonNumber = -1;
    private int MaxReports = 20;
    private bool purgeReports = true;
    private bool useLastReportTime = false;
    [HideInInspector]
    public bool ShowDebug = false;
    
    // Private Variables
	private bool initialized = false;
	private VRPNManager.TimeVal LastReport;// = new VRPNManager.TimeVal();
    private IntPtr[] reportsPtr;
	private string debug_text = "";
	private int debug_xoffset;
        
    // VRPNWrapper Function Imports
    [DllImport ("VRPNWrapper")]
    private static extern void VRPNButtonStart(string name);
        
    [DllImport ("VRPNWrapper")]
    private static extern void VRPNButtonReport(string name, [In,Out] IntPtr rep, [Out] IntPtr ts, int button);
    
    [DllImport ("VRPNWrapper")]
    private static extern int VRPNButtonNumReports(string name);

    [DllImport ("VRPNWrapper")]
    private static extern void VRPNButtonReports(string name, [In,Out] IntPtr[] reportsPtr, [In,Out] ref int cnt, [In, MarshalAs(UnmanagedType.LPStruct)] VRPNManager.TimeVal ts, int btn_num, bool clearReport);
  
    
    // Functions

    void Start() {
    	//allocate unmanaged memory for button reports
		reportsPtr = new IntPtr[MaxReports];
		ButtonReport report = new ButtonReport();
		report.button = 0;
		report.state = 0;
		for(int i=0; i<MaxReports ; i++)
		{
			reportsPtr[i] = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ButtonReport)));
			Marshal.StructureToPtr(report, reportsPtr[i], true);
		}
        
        // Setup last report time memory
		LastReport = new VRPNManager.TimeVal();
    }

	private bool StartButton () {        
        if (VRPNManager.initialized)
        {
            // Register Button Device
            VRPNButtonStart(ButtonName.ToString());
            num_buttons++;
            
            // Set up debug window
            if (ShowDebug)
            {
                debug_xoffset = num_buttons*210;
                if (VRPNManager.debug_flag)
                    debug_xoffset += 405;
            }
            initialized = true;
            return true;
        }
        return false;
	}
	
	// Update is called once per frame
	void Update () {       
        // Ensure device is ready
        if (!initialized && !StartButton()) return;
        
        // Check for new reports and process
        if (VRPNButtonNumReports(ButtonName.ToString()) > 0)
        {
            // Get Reports
            int num = MaxReports;
            VRPNButtonReports(ButtonName.ToString(),reportsPtr, ref num, LastReport, ButtonNumber, purgeReports);
            ButtonReport[] reports = new ButtonReport[num];
            
            // Process Reports
            int i;
            string reportString = ButtonName.ToString();
            for (i = 0; i < num; i++)
            {
                reports[i] = (ButtonReport)Marshal.PtrToStructure(reportsPtr[i],typeof(ButtonReport));
                //Trigger button event in event manager
                VRPNEventManager.TriggerEventButton(ButtonType.ToString(), ButtonName.ToString(), reports[i]);
                if (ShowDebug) reportString += "\n " + reports[i].button + "->" + reports[i].state + " @ " + reports[i].msg_time.tv_sec + "." + reports[i].msg_time.tv_usec;
            }
            
            if (ShowDebug) debug_text = reportString;
            
            // Only need time value of most recent report
            if(num>0 && useLastReportTime)
            {
                LastReport.tv_sec = reports[num-1].msg_time.tv_sec;
                LastReport.tv_usec = reports[num-1].msg_time.tv_usec;
            }
        
        }  
      
	}
    
    void OnGUI () {
		if (ShowDebug) {
			GUI.skin.box.alignment = TextAnchor.LowerLeft;
			GUI.Box(new Rect(debug_xoffset + 10, 10, 200, 45), debug_text);		
		}
	}
   
}
